# Feature Feasibility Analysis

This document provides a feasibility analysis for the features proposed in `FEATURES.md`, based on the current codebase and the Cribl API documentation (v4.15.1).

## 1. Observability and Metrics Overlay

### 1.1 Live Traffic Indicators
**Feasibility:** High
**Description:** Integrate with Cribl's metrics API to overlay EPS or byte throughput on graph edges.
**Analysis:**
-   **API Endpoints:**
    -   `/system/metrics` and `/system/metrics/query` allow querying system metrics.
    -   Specific metrics like `cribl.logstream.input.bytes` or `cribl.logstream.output.events` can likely be queried.
    -   `/system/status/inputs` and `/system/status/outputs` might also provide real-time stats.
-   **Implementation:** Requires fetching metrics for each input/output and updating edge labels or styles in Graphviz.
-   **Challenges:** Correlating generic metrics to specific graph edges (pipelines) might require careful query construction.

### 1.2 Health Status
**Feasibility:** High
**Description:** Color-code nodes based on health status or error rates.
**Analysis:**
-   **API Endpoints:**
    -   `/system/status/inputs` returns a list of Source Status objects.
    -   `/system/status/outputs` returns a list of Destination Status objects.
-   **Implementation:** Retrieve status objects, map them to graph nodes by ID, and apply conditional formatting (e.g., `fillcolor="red"` for errors).
-   **Challenges:** Defining "unhealthy" thresholds if the API only returns raw counters (though "health" fields are likely present).

## 2. Configuration Analysis and Validation

### 2.1 Orphan Detection
**Feasibility:** High
**Description:** Visually flag unconnected inputs or outputs.
**Analysis:**
-   **Current Logic:** The graph generator already iterates through connections.
-   **Implementation:**
    -   **Inputs:** Identify inputs with empty `connections` or connections to non-existent pipelines/routes.
    -   **Outputs:** Identify outputs that are not referenced by any pipeline or route.
-   **Challenges:** Minimal. Can be done entirely with existing configuration data.

### 2.2 Disabled/Inactive Highlighting
**Feasibility:** High
**Description:** Show disabled routes/sources in a faded state.
**Analysis:**
-   **Current Logic:** The codebase currently *skips* disabled inputs (`if not input_data.get("disabled", False):`).
-   **Implementation:** Modify `graph_generator.py` to include disabled nodes but style them differently (e.g., `style="dashed"`, `fontcolor="gray"`).
-   **Challenges:** Minimal.

### 2.3 Complexity Scoring
**Feasibility:** Medium
**Description:** Highlight overly complex pipelines.
**Analysis:**
-   **API Endpoints:**
    -   The `Pipeline` object contains a `functions` array (list of `PipelineFunctionConf`).
    -   `/m/{group}/pipelines` retrieves pipeline configurations.
-   **Implementation:**
    -   Fetch full pipeline configurations (currently arguably missing from the simple `get_pipelines` usage in `graph_generator.py`).
    -   Count the number of items in the `functions` array for each pipeline.
    -   Apply visual cues (e.g., bold borders) for counts exceeding a threshold.
-   **Challenges:** Requires fetching detailed pipeline configs, which might add latency for large deployments.

## 3. Interactive and Navigation Features

### 3.1 Highlight Paths
**Feasibility:** Medium
**Description:** Click an Input to highlight downstream paths.
**Analysis:**
-   **Implementation:** This is primarily a frontend (JavaScript) task. The SVG generated by Graphviz can have classes and IDs.
-   **Requirements:**
    -   Embed the SVG in the HTML page (already done).
    -   Add JavaScript to handle click events on SVG elements.
    -   Traverse the DOM or a separate graph data structure to find connected nodes.
-   **Challenges:** Graphviz SVGs structure isn't always easy to traverse via DOM. Might need to inject custom attributes or generate a separate mapping JSON.

### 3.2 Search and Filter
**Feasibility:** High
**Description:** Search bar to find and zoom in on nodes.
**Analysis:**
-   **Implementation:** Frontend (JavaScript).
    -   List all node IDs/Labels.
    -   Implement a search box.
    -   On selection, use JS to scroll/zoom to the corresponding SVG element.
-   **Challenges:** Minimal.

### 3.3 Click-to-Edit
**Feasibility:** High
**Description:** Hyperlinks to the Cribl Stream UI.
**Analysis:**
-   **Implementation:**
    -   Construct URLs based on the base URL and node ID (e.g., `.../jobs/config/outputs/{id}`).
    -   Graphviz supports `URL` attributes for nodes.
-   **Challenges:** Determining the correct deep-link URL structure for all node types.

## 4. Versioning and Environment Comparisons

### 4.1 Environment Diffing
**Feasibility:** High
**Description:** Diff pipelines between environments (e.g., Dev vs. Prod).
**Analysis:**
-   **API Endpoints:**
    -   `/version/diff` and `/version/show` allow retrieving diffs.
    -   Alternatively, if "environments" mean separate Cribl instances, the app is already architected to connect to one. It would need to connect to *two*.
-   **Implementation:**
    -   Instantiate two `CriblAPI` clients.
    -   Fetch configs from both.
    -   Compare the sets of objects and their configurations.
    -   Generate a graph highlighting added/removed/modified nodes.
-   **Challenges:** Handling the complexity of a "diff graph" visualization.

### 4.2 Git Integration
**Feasibility:** Very High
**Description:** Visualize impact of PRs or changes over time.
**Analysis:**
-   **API Endpoints:**
    -   Extensive Git support: `/version/branch`, `/version/commit`, `/version/log`, `/version/status`.
-   **Implementation:**
    -   Fetch commit history.
    -   Allow selecting a commit to visualize the state *at that point in time* (if the API supports "checkout" or retrieving historical configs, which is harder).
    -   Or, visualize the *current* uncommitted changes using `/version/status` and `/version/diff`.
-   **Challenges:** "Time travel" visualization depends on the API's ability to return full configs for past commits without actually rolling back the system (which might be disruptive). Visualizing *pending* changes (GitOps) is safer and very feasible.

## 5. Documentation and Export

### 5.1 Automated Wiki Sync
**Feasibility:** Medium
**Description:** Scheduled export to Confluence/Wiki.
**Analysis:**
-   **Implementation:**
    -   Script the existing graph generation.
    -   Use Confluence API (or target system API) to upload the image.
-   **Challenges:** External system integration (auth, API format) is the main variable.

### 5.2 Embeddable View
**Feasibility:** High
**Description:** Iframe-friendly route.
**Analysis:**
-   **Implementation:**
    -   Create a new Flask route (e.g., `/embed`) that renders *only* the SVG, without headers/footers/nav.
-   **Challenges:** Minimal.

---

## Summary of Recommendations

1.  **Immediate Wins (Low Effort / High Value):**
    -   **2.1 Orphan Detection:** Pure logic change, high value for cleanup.
    -   **2.2 Disabled Highlighting:** Simple styling change, great visibility improvement.
    -   **5.2 Embeddable View:** Trivial to add a "clean" route.

2.  **High Value / Medium Effort:**
    -   **1.2 Health Status:** Adds significant operational value. Requires mapping status API to nodes.
    -   **3.3 Click-to-Edit:** Great UX improvement. Requires URL reverse-engineering.

3.  **Advanced Features:**
    -   **Git/Versioning:** The API support is excellent. Building a "GitOps Visualizer" that shows what a pending commit *will* do to the graph would be a killer feature.
